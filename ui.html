<section id="select-section" class="section section--select">
  <h2>Flow to mp4</h2>
  <select id="select-flow" value="">
    <option value="" selected>Fetching flows...</option>
  </select>
</section>

<section id="export-section" class="section section--export">
  <header style="display: flex; align-items: center; column-gap: 1rem">
    <button id="back-button">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="8">
        <path
          d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"
        />
      </svg>
      Back
    </button>
    <h2>Export the flow</h2>
  </header>
  <div id="preview">
    <div id="frames-container"></div>
    <p id="preview-placeholder">Loading preview...</p>
  </div>
  <button id="export-button">Export to MP4</button>
</section>

<script>
  class Navigator {
    constructor(pages, initialIndex = 0) {
      if (!pages.length) {
        throw new Error("Pages cannot be empty");
      }
      if (initialIndex < 0 || initialIndex >= pages.length) {
        throw new Error("Initial index must be within pages bounds.");
      }
      this.history = [initialIndex];
      this.pages = pages;
      this.#update();
    }
    #update() {
      const currentIndex = this.#currentIndex();
      this.pages.forEach((page, index) => {
        if (index === currentIndex) {
          page.mount();
        } else {
          page.detach();
        }
      });
    }
    #currentIndex() {
      return this.history.at(-1);
    }
    push(index) {
      this.history.push(index);
      this.#update();
    }
    replace(index) {
      if (this.size() > 0) {
        this.history = [...this.history.slice(0, -1), index];
      } else {
        this.history.push(index);
      }
      this.#update();
    }
    pop() {
      this.history.pop();
      this.#update();
    }
    size() {
      return this.pages.length;
    }
  }

  class Page {
    constructor(selector, onMount) {
      this.selector = selector;
      this.onMount = onMount;
    }
    #getElement() {
      const el = document.querySelector(this.selector);
      if (!el) {
        throw new Error("Element not found");
      }
      return el;
    }
    mount() {
      const el = this.#getElement();
      el.style.display = "block";
      this.onDetach = this.onMount(el);
    }
    detach() {
      const el = this.#getElement();
      el.style.display = "none";
      if (this.onDetach) {
        this.onDetach();
      }
    }
  }

  const state = {
    flowStartingPoints: [],
    exportData: null,
    signals: {
      _notify() {
        [...this.subscribers.values()].forEach((fn) => fn(state));
      },
      subscribers: new Map(),
      subscribe(id, fn) {
        this.subscribers.set(id, fn);
      },
      unsubscribe(id) {
        this.subscribers.delete(id);
      },
      set(key, value) {
        state[key] = value;
        this._notify();
      },
    },
  };

  const navigator = new Navigator([
    new Page("#select-section", function (section) {
      const STATE_SUBSCRIPTION_ID = "state:subscriber:select-section";
      const selectFlow = section.querySelector("#select-flow");

      const initSelectOptions = (flowStartingPoints) => {
        selectFlow.innerHTML = [
          `<option value="" selected>--Select Prototype Flow--</option>`,
          ...[...flowStartingPoints].map(
            (flow) => `<option value="${flow.nodeId}">${flow.name}</option>`
          ),
        ];
      };

      const handleSelectFlow = (event) => {
        const value = event.target.value;
        if (value) {
          navigator.push(1);
          parent.postMessage(
            { pluginMessage: { type: "select-flow", flow: value } },
            "*"
          );
        }
      };

      selectFlow.addEventListener("change", handleSelectFlow);

      state.signals.subscribe(STATE_SUBSCRIPTION_ID, (state) => {
        initSelectOptions(state.flowStartingPoints);
      });

      initSelectOptions(state.flowStartingPoints);

      return () => {
        selectFlow.removeEventListener("change", handleSelectFlow);
        state.signals.unsubscribe(STATE_SUBSCRIPTION_ID);
      };
    }),
    new Page("#export-section", function (section) {
      const STATE_SUBSCRIPTION_ID = "state:subscriber:export-section";
      const backButton = section.querySelector("#back-button");
      const exportButton = section.querySelector("#export-button");
      const preview = section.querySelector("#preview");
      const previewPlaceholder = preview.querySelector("#preview-placeholder");
      const framesContainer = section.querySelector("#frames-container");

      const handleGoBack = (event) => {
        event.preventDefault();
        navigator.pop();
      };

      const handleExport = (event) => {
        event.preventDefault();
        exportMP4(state.exportData);
      };

      const loadPreview = ({ frames, transitions }) => {
        framesContainer.innerHTML = "";

        frames.forEach((frame) => {
          let imageAsBase64;
          try {
            imageAsBase64 = bufferToBase64(frame.image);
          } catch (err) {
            console.error("Error converting to base64", err);
          }

          const frameDiv = document.createElement("div");
          frameDiv.class = "frame";
          frameDiv.innerHTML = `<h2>Frame: ${
            frame.id
          }</h2><img width="400px" height="${
            400 * (frame.height / frame.width)
          }px" src="${imageAsBase64}" />`;
          framesContainer.appendChild(frameDiv);
        });

        exportButton.disabled = false;
        previewPlaceholder.style.display = "none";
      };

      exportButton.disabled = true;
      backButton.addEventListener("click", handleGoBack);
      exportButton.addEventListener("click", handleExport);
      if (state.exportData) {
        loadPreview(state.exportData);
      }

      state.signals.subscribe(STATE_SUBSCRIPTION_ID, (state) => {
        if (state.exportData) {
          loadPreview(state.exportData);
        }
      });

      return () => {
        backButton.removeEventListener("click", handleGoBack);
        state.signals.unsubscribe(STATE_SUBSCRIPTION_ID);
      };
    }),
  ]);

  window.onmessage = (event) => {
    if (!event?.data?.pluginMessage) {
      return;
    }

    const data = event.data.pluginMessage;

    if (data.type === "export") {
      state.signals.set("exportData", data);
    } else if (data.type === "flow-starting-points") {
      state.signals.set("flowStartingPoints", data.flows);
    }
  };

  function bufferToBase64(uint8Array) {
    let binary = "";
    const len = uint8Array.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(uint8Array[i]);
    }
    return `data:image/png;base64,${btoa(binary)}`;
  }

  async function exportMP4(frames) {
    if (frames.length === 0) {
      alert("No frames available for export.");
      return;
    }

    const { fetchFile } = FFmpegUtil;
    const { FFmpeg } = FFmpegWASM;
    const { createFFmpeg } = FFmpeg;
    const ffmpeg = createFFmpeg({ log: true });

    await ffmpeg.load();

    // Save images as input files
    for (let i = 0; i < frames.length; i++) {
      const blob = new Blob([new Uint8Array(frames[i].image)], {
        type: "image/png",
      });
      const url = URL.createObjectURL(blob);
      const response = await fetch(url);
      const file = await response.blob();
      await ffmpeg.FS("writeFile", `frame${i}.png`, await fetchFile(file));
    }

    // Run ffmpeg command to create MP4
    await ffmpeg.run(
      "-framerate",
      "60", // 60 FPS
      "-i",
      "frame%d.png", // Input pattern
      "-c:v",
      "libx264",
      "-pix_fmt",
      "yuv420p",
      "output.mp4"
    );

    // Get the MP4 file
    const data = ffmpeg.FS("readFile", "output.mp4");
    const mp4Blob = new Blob([data.buffer], { type: "video/mp4" });
    const url = URL.createObjectURL(mp4Blob);

    // Create download link
    const a = document.createElement("a");
    a.href = url;
    a.download = "figma-animation.mp4";
    a.click();
  }
</script>
